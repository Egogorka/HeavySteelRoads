---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Meevere.
--- DateTime: 23.10.2022 14:59
---

local anim8 = require("libs/anim8")
local Vector2, Vector3 = unpack(require("utility/vector"))

-----------------------------------------
--- classes
-----------------------------------------

---
--- z - value of depth
--- scalable - determines if sprite would be scaled with depth
---

local Depth = CLASS("Depth", {
    z = 1,
    scalable = true
})

--- @class Placement
--- @field offset Vector2
--- @field z_index number
local Placement = CLASS("Placement", {
    offset = Vector2(0,0),
    z_index = 0, -- higher - 'closer' to the screen in terms of order of sprites
})

--- @class Sprite
---  @field animations table<string, {animation : table, image : love.Image}> Array listing animations
---  @field current_animation string 
---  @field is_flippedH boolean
---  @field is_flippedV boolean
---
---  @field scale number
---  @field offset Vector2
---  @field origin Vector2 
---  @field camera_affected boolean
---
---  @field effect Effect
local Sprite = CLASS("Sprite", {
    animations = {},
    current_animation = "default",

    scale = 1,
    offset = Vector2(),
    origin = Vector2(),

    camera_affected = true,
    effect = nil,

    is_flippedH = false,
    is_flippedV = false,
})

-- Short for MultipleSprite
--- @class MSprite 
---  @field sprites table<string, {sprite: Sprite, placement: Placement}> 
---  @field sprites_z_order string[]
---  
---  @field scale number
---  @field effect Effect
---  
---  @field is_flippedH boolean
---  @field is_flippedV boolean
local MSprite = CLASS("MSprite", {
    sprites = {
        default = Sprite(love.graphics.newImage("assets/placeholder.png")),
    },
    sprites_z_order = {"default"}, --- sprites Z order
    scale = 1,

    effect = nil,

    is_flippedH = false,
    is_flippedV = false,
})

-----------------------------------------
--- Depth implementation
-----------------------------------------

function Depth:init(z, scalable)
    self.z = z

    if( scalable ~= nil ) then
        self.scalable = scalable
    end
end

-----------------------------------------
--- Placement implementation
-----------------------------------------

function Placement:init(offset, z_index)
    if(offset ~= nil) then
        self.offset = Vector2(offset)
    end
    if(z_index ~= nil) then
        self.z_index = z_index
    end
end

-----------------------------------------
--- Sprite implementation
-----------------------------------------

function Sprite:init(o, camera_affected, offset, origin, scale)
    if not o then
        return
    end

    if(offset ~= nil) then
        self.offset = offset
    end
    if(origin ~= nil) then
        self.origin = origin
    end
    if(scale ~= nil) then
        self.scale = scale
    end
    if(camera_affected ~= nil) then
        self.camera_affected = camera_affected
    end

    if( o["type"] ~= nil and o:type() == "Image") then
        local grid = anim8.newGrid(o:getWidth(), o:getHeight(), o:getWidth(), o:getHeight())
        self.animations = {
            default = {
                animation = anim8.newAnimation(grid(1,1), 1),
                image = o
            }
        }
        self.current_animation = "default"
    else
        self.current_animation = o.current_animation

        self.animations = {}
        for k, v in pairs(o.animations) do
            self.animations[k] = {
                animation = v.animation:clone(),
                image = v.image
            }
        end
    end
end


---Set the current animation by name
---@param type string
function Sprite:set(type)
    if( self.animations[type] == nil or self.current_animation == type) then
        return
    end
    self:current().animation:gotoFrame(1) -- reset the previous animation
    self.current_animation = type
end


---Get current animation
---@return { animation : table, image : love.Image }
function Sprite:current()
    return self.animations[self.current_animation]
end


function Sprite:size()
    local anim = self:current().animation
    local w, h = anim:getDimensions()
    return Vector2(w, h)
end


function Sprite:flipH()
    for _, animation in pairs(self.animations) do
        animation.animation:flipH()
    end
    self.is_flippedH = not self.is_flippedH
end


function Sprite:flipV()
    for _, animation in pairs(self.animations) do
        animation.animation:flipV()
    end
    self.is_flippedV = not self.is_flippedV
end


---Clone sprite
---@return Sprite
function Sprite:clone()
    return Sprite(self, self.camera_affected, self.offset, self.origin, self.scale)
end

-----------------------------------------
--- MSprite implementation
-----------------------------------------

local function my_sort(t, ord)
    -- Construct table from keys and values => {key, value}
    local temp = {}
    for k, v in pairs(t) do
        table.insert(temp, {key=k, value=v})
    end
    table.sort(temp, function(a, b) return ord(a.value, b.value) end)
    local out = {}
    for i, v in ipairs(temp) do
        table.insert(out, i, v.key)
    end
    return out
end


function MSprite:sort()
    self.sprites_z_order = my_sort(self.sprites, function(a, b) return a.placement.z_index < b.placement.z_index end)
end


function MSprite:init(o, scale)
    if(o["type"] ~= nil and o:type() == "Image") then
        self.sprites.default.sprite = Sprite(o)
        self.sprites.default.placement = Placement()
    elseif(o ~= nil) then
        local source = o
        if(o.sprites ~= nil) then
            source = o.sprites
        end
        self.sprites = {}
        for k, v in pairs(source) do
            self.sprites[k] = {
                sprite = v.sprite:clone(),
                placement = v.placement
            }
        end
    end

    if(scale ~= nil) then
        self.scale = scale
    end

    -- Presort sprites according to their placement z_index
    self:sort()
end


function MSprite:flipH()
    for key in pairs(self.sprites) do
        self.sprites[key].sprite:flipH()
    end
    self.is_flippedH = not self.is_flippedH
end


function MSprite:flipV()
    for key in pairs(self.sprites) do
        self.sprites[key].sprite:flipV()
    end
    self.is_flippedV = not self.is_flippedV
end


---Clone MSprite
---@return MSprite
function MSprite:clone()
    return MSprite(self, self.scale)
end

return {Sprite, MSprite, Depth, Placement}