---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Meevere.
--- DateTime: 27.11.2022 0:20
---

--- Example of tank component
--- tank = {
---     aim = Vector2() | nil - at what coordinate it aims
--- }

local Vector2 = require("utility/vector")[1]
local Stack = require("utility/stack")
local dump = require("utility/dump")
local Torus = require("utility/torus")
local Timer = require("utility/timer")

local Sprite = require("src/graphics/Sprite")[1]
local CategoryManager = require("src/CategoryManager")
local Effects = require("src/graphics/Effects")

local tiny = require("libs/tiny")


local TankBehavior = tiny.processingSystem()
TankBehavior.filter = tiny.requireAll("tank", "body", "msprite")

TankBehavior.states = {
    ramming = {
        shoot = true, move = true
    }
}

function TankBehavior:onAdd(entity)
    fill_table(entity.tank, {
        messages = Stack(),
        stack = Stack(),

        shoot_reload_timer = Timer(1),

        aimed = false,
        rotation_speed = 1,
        rotation_angle = 0, -- In units of Pi : Right is 0, Down is 1/2
        target_angle = 0,

        ram_reload_timer = Timer(2),
        ram_pre_timer = Timer(1),
        ram_pos = nil,

        -- Default team setting - enemy
        team = CategoryManager.categories.enemy
    })
    entity.tank.ram_pre_timer.on_end = function(timer) self:_ram(entity) end

    CategoryManager.setObject(entity.fixture, entity.tank.team)
end

--- Aim block
local function tower_state(phi)
    if( phi > 7/8 ) then
        return "left"
    end
    if( phi > 5/8) then
        return "left_down"
    end
    if( phi > 3/8) then
        return "down"
    end
    if( phi > 1/8) then
        return "right_down"
    end
    if( phi > -1/8) then
        return "right"
    end
    if( phi > -3/8) then
        return "right_up"
    end
    if( phi > -5/8) then
        return "up"
    end
    if( phi > -7/8) then
        return "left_up"
    end
    return "left"
end

function TankBehavior:process(entity, dt)
    local tank = entity.tank

    tank.shoot_reload_timer:update(dt)
    tank.ram_reload_timer:update(dt)
    tank.ram_pre_timer:update(dt)

    if not tank.aimed then
        local t_current = Torus(tank.rotation_angle/2 + 1/2)
        local t_target = Torus(tank.target_angle/2 + 1/2)

        local dist = Torus.dist(t_current - t_target)
        local dir = Torus.dir(t_current, t_target) and 1 or -1

        if 2*dist < tank.rotation_speed * dt then
            tank.rotation_angle = tank.target_angle
            tank.aimed = true
        else
            tank.rotation_angle = tank.rotation_angle + dir * tank.rotation_speed * dt
        end

        tank.rotation_angle = Torus(tank.rotation_angle/2 + 1/2).a * 2 - 1

        entity.msprite.sprites.tower.sprite:set(tower_state(tank.rotation_angle))
    end

    -- Command logic
    while tank.messages:size() ~= 0 do
        local message = tank.messages:pop()
        local command = message[1]

        if tank.ram_reload_timer.is_on and self.states.ramming[command] then
            goto continue
        end

        if self[command] then
            self[command](self, entity, dt, message[2])
        end
        ::continue::
    end
end

function TankBehavior:ram(entity, dt, pos)
    entity.tank.ram_reload_timer:start()
    entity.tank.ram_pre_timer:start()
    entity.msprite.effect = Effects.ram()
    entity.tank.ram_pos = Vector2(pos)
end

function TankBehavior:_ram(entity)
    local temp = entity.tank.ram_pos - Vector2(entity.body:getPosition())
    local dir = temp / temp:mag() * 500

    entity.msprite.sprites.body.sprite:set("move")
    entity.body:setLinearVelocity(dir:x(), dir:y())
end

--- Move block
---@param vel - Vector2
function TankBehavior:move(entity, dt, vel)
    local temp = Vector2(vel)
    local velocity = temp / temp:mag() * 100

    --entity.tank.is_moving = true
    entity.msprite.sprites.body.sprite:set("move")
    entity.body:setLinearVelocity(velocity:x(), velocity:y())
end

function TankBehavior:stop(entity, dt)
    --entity.tank.is_moving = false
    entity.msprite.sprites.body.sprite:set("idle")
    entity.body:setLinearVelocity(0, 0)
end


---@param aim - Vector2
function TankBehavior:aim(entity, dt, aim)
    if aim then
        local position = Vector2(entity.body:getPosition())
        entity.tank.target_angle = (aim - position):angle()/math.pi
        entity.tank.aimed = false
    else
        entity.tank.aimed = true
    end
end


--- Shoot block

function TankBehavior:_bullet(entity)
    local p_world = entity.body:getWorld()
    local world = self.world
    local x, y = entity.body:getPosition()

    local bullet = {
        sprite = Sprite(love.graphics.newImage("assets/player/Bullet1.png")),
        shape = love.physics.newRectangleShape(10, 10),
        bullet = {},
        behavior = "bullet"
    }
    bullet.body = love.physics.newBody(p_world, x+15, y, "kinematic")
    bullet.body:setFixedRotation(true)
    bullet.fixture = love.physics.newFixture(bullet.body, bullet.shape)
    bullet.fixture:setSensor(true)
    bullet.fixture:setUserData({ entity = bullet })

    -- TODO: This is a bad thing. Need to add category.Team2Bullet, but this looks cleaner now
    CategoryManager.setBullet(bullet.fixture, entity.tank.team + 1)

    world:addEntity(bullet)
    return bullet
end

function TankBehavior:shoot(entity, dt)

    if entity.tank.shoot_reload_timer.is_on or not entity.tank.aimed then
        return
    end
    entity.tank.shoot_reload_timer:start()

    local vel = 300 * Vector2.fromPolar(1, entity.tank.rotation_angle * math.pi)
    local bullet = self:_bullet(entity)
    bullet.body:setLinearVelocity(vel[1], vel[2])
    bullet.body:setAngle(entity.tank.rotation_angle * math.pi)
end

function TankBehavior:hurt(entity, dt)
    if entity.msprite.effect == nil then
        entity.msprite.effect = Effects.hurt()
    end
end

function TankBehavior:die(entity, dt)
    local world = self.world
    tiny.removeEntity(world, entity)
end

function TankBehavior:onRemove(entity)
    entity.body:destroy()
end

return TankBehavior