---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Meevere.
--- DateTime: 27.11.2022 0:20
---

--- Example of tank component
--- tank = {
---     aim = Vector2() | nil - at what coordinate it aims
--- }

local Vector2 = require("utility/vector")[1]
local Stack = require("utility/stack")
local dump = require("utility/dump")
local Torus = require("utility/torus")

local Sprite = require("src/graphics/Sprite")[1]
local CategoryManager = require("src/CategoryManager")

local tiny = require("libs/tiny")


local TankBehavior = tiny.processingSystem()
TankBehavior.filter = tiny.requireAll("tank", "body", "msprite")

function TankBehavior:onAdd(entity)
    fill_table(entity.tank, {
        messages = Stack(),

        reloaded = true,
        shoot_timer = 0,
        shoot_timer_max = 1,

        aimed = false,
        rotation_speed = 1,
        rotation_angle = 0, -- In units of Pi : Right is 0, Down is 1/2
        target_angle = 0
    })
end

--- Aim block
local function tower_state(phi)
    if( phi > 7/8 ) then
        return "left"
    end
    if( phi > 5/8) then
        return "left_down"
    end
    if( phi > 3/8) then
        return "down"
    end
    if( phi > 1/8) then
        return "right_down"
    end
    if( phi > -1/8) then
        return "right"
    end
    if( phi > -3/8) then
        return "right_up"
    end
    if( phi > -5/8) then
        return "up"
    end
    if( phi > -7/8) then
        return "left_up"
    end
    return "left"
end

function TankBehavior:process(entity, dt)
    local tank = entity.tank

    if not tank.reloaded then
        tank.shoot_timer = tank.shoot_timer + dt
        if tank.shoot_timer > tank.shoot_timer_max then
            tank.shoot_timer = 0
            tank.reloaded = true
        end
    end

    if not tank.aimed then
        local t_current = Torus(tank.rotation_angle/2 + 1/2)
        local t_target = Torus(tank.target_angle/2 + 1/2)

        local dist = Torus.dist(t_current - t_target)
        local dir = Torus.dir(t_current, t_target) and 1 or -1

        if 2*dist < tank.rotation_speed * dt then
            tank.rotation_angle = tank.target_angle
            tank.aimed = true
        else
            tank.rotation_angle = tank.rotation_angle + dir * tank.rotation_speed * dt
        end

        tank.rotation_angle = Torus(tank.rotation_angle/2 + 1/2).a * 2 - 1

        entity.msprite.sprites.tower.sprite:set(tower_state(tank.rotation_angle))
    end

    -- Command logic
    while tank.messages:size() ~= 0 do
        --print("Command: \n", dump(entity.tank.messages:lookup(), 2, 2))
        local message = tank.messages:pop()
        local command = message[1]

        if self[command] then
            self[command](self, entity, dt, message[2])
        end
    end
end

--- Move block
---@param vel - Vector2
function TankBehavior:move(entity, dt, vel)
    local velocity = vel * 100

    --entity.tank.is_moving = true
    entity.msprite.sprites.body.sprite:set("move")
    entity.body:setLinearVelocity(velocity:x(), velocity:y())
end

function TankBehavior:stop(entity, dt)
    --entity.tank.is_moving = false
    entity.msprite.sprites.body.sprite:set("idle")
    entity.body:setLinearVelocity(0, 0)
end


---@param vel - Vector2
function TankBehavior:aim(entity, dt, aim)
    local position = Vector2(entity.body:getPosition())
    entity.tank.target_angle = (aim - position):angle()/math.pi
    entity.tank.aimed = false
end


--- Shoot block

function TankBehavior:_bullet(entity)
    local p_world = entity.body:getWorld()
    local world = self.world
    local x, y = entity.body:getPosition()

    local bullet = {
        sprite = Sprite(love.graphics.newImage("assets/player/Bullet1.png")),
        shape = love.physics.newRectangleShape(10, 10),
        bullet = {},
        behavior = "bullet"
    }
    bullet.body = love.physics.newBody(p_world, x+15, y, "kinematic")
    bullet.body:setFixedRotation(true)
    bullet.fixture = love.physics.newFixture(bullet.body, bullet.shape)
    bullet.fixture:setSensor(true)
    bullet.fixture:setUserData({
        entity = bullet
    })

    CategoryManager.setBullet(bullet.fixture, CategoryManager.categories.player_bullets)

    --print(dump(bullet, 2, 2))
    world:addEntity(bullet)
    return bullet
end

function TankBehavior:shoot(entity, dt)

    if not entity.tank.reloaded then
        return
    end
    entity.tank.reloaded = false

    local vel = 500 * Vector2.fromPolar(1, entity.tank.rotation_angle * math.pi)
    local bullet = self:_bullet(entity)
    bullet.body:setLinearVelocity(vel[1], vel[2])
    bullet.body:setAngle(entity.tank.rotation_angle * math.pi)
end

function TankBehavior:hurt(entity, dt)
    entity.msprite.sprites.body.sprite.hurt_effect = true
    entity.msprite.sprites.tower.sprite.hurt_effect = true
end

function TankBehavior:die(entity, dt)
    local world = self.world
    tiny.removeEntity(world, entity)
end

function TankBehavior:onRemove(entity)
    entity.body:destroy()
end

return TankBehavior