---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Meevere.
--- DateTime: 08.03.2023 12:12
---

local Vector2 = require("utility/vector")[1]
local Stack = require("utility/stack")
local UserData = require("src/physics/UserData")

local CategoryManager = require("src/physics/CategoryManager")
local StateMachine = require("src/controllers/StateMachine")
local DetectorBox = require("src/controllers/DetectorBox")

local AITank = TINY.processingSystem(StateMachine:extend("AITank"))
AITank.filter = TINY.requireAll("tank", "ai")

local Timer = require("utility/timer")

function AITank:init()
    self.target = nil
end

function AITank:onAdd(entity)
    AITank.super.onAdd(self, entity)

    DetectorBox.init(entity, {50/2, 20/2}, {100, 20}, "ram_box")
    DetectorBox.init(entity, {50/2, 20/2}, {400, 400}, "shoot_box")
    self:init_shoot(entity)
end

-----------------------------------------
--- Idle state
-----------------------------------------

function AITank:idle(entity, dt)
    local ai = entity.ai

    -- Handle state

    entity.tank.messages:push({"move", Vector2({-0.3, 0})})


    -- State out branches

    if ai.in_ram_box and not entity.tank.ram_reload_timer.is_on then
        ai.ram_pos = Vector2(ai.target.body:getPosition()) -- State start code
        entity.tank.messages:push({"ram", entity.ai.ram_pos})
        ai.states:push("ram")
        return
    end

    if ai.in_shoot_box then
        ai.stare_timer:start() -- State start code
        ai.target_pos = Vector2(ai.target.body:getPosition())
        ai.states:push("action")
        return
    end

    ai.states:push("idle") -- refill idle state

    -- Action if no state change
    entity.tank.messages:push({"aim", Vector2(entity.body:getPosition()) + {-10, 0}})

end

-----------------------------------------
--- Ram state
-----------------------------------------

function AITank:ram(entity, dt)
    -- Needs to be fixed
    if entity.tank.ram_timer.is_on or entity.tank.ram_pre_timer.is_on then
        entity.ai.states:push("ram")
    end
end

-----------------------------------------
--- Action state (shooting, going around the player to go left)
-----------------------------------------

function AITank:init_shoot(entity)
    local stare_timer = Timer(1)
    stare_timer.on_end = function(timer)
        entity.tank.messages:push({"shoot"})
    end

    fill_table(entity.ai, {
        target = self.target,
        target_pos = nil,

        stare_timer = stare_timer
    })
end

function AITank:action(entity, dt)
    local ai = entity.ai
    local tank = entity.tank

    tank.messages:push({"aim", ai.target_pos})
    if not ai.stare_timer.is_on then
        ai.stare_timer:start()
    end
    if not ai.target.body:isDestroyed() then
        ai.target_pos = Vector2(ai.target.body:getPosition())
    end
    ai.stare_timer:update(dt)

    local d = ai.target_pos - {entity.body:getPosition()}

    if math.abs(d:y()) < 40 then
        local dir = 0.3
        if d:y() < 0 then dir = -dir end
        entity.tank.messages:push({"move", {0, -dir}})
    else
        entity.tank.messages:push({"move", {-0.3, 0}})
    end

    -- This one is bad in some sense
    -- I need to avoid duplication and writing state CLASS code
    if ai.in_shoot_box and not (ai.in_ram_box and not entity.tank.ram_reload_timer.is_on) then
        ai.states:push("action")
    end
end

-----------------------------------------
--- Contact handlers
-----------------------------------------

function AITank:contact(entity, dt, data)
    DetectorBox.onContact(entity, data, entity.ai.target, "shoot_box")
    DetectorBox.onContact(entity, data, entity.ai.target, "ram_box")
end

function AITank:endContact(entity, dt, data)
    DetectorBox.onEndContact(entity, data, entity.ai.target, "shoot_box")
    DetectorBox.onEndContact(entity, data, entity.ai.target, "ram_box")
end


return AITank

