---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Meevere.
--- DateTime: 08.03.2023 12:12
---

local class = require("libs/30log")
local CategoryManager = require("src/CategoryManager")

local AITank = tiny.processingSystem(class("AITank"))
AITank.filter = tiny.requireAll("tank", "ai")

function AITank:init()
    self.target = nil
end

function AITank:onAdd(entity)
    local shoot_box = {}

    shoot_box.shape = love.physics.newRectangleShape(50/2, 20/2, 400, 400)
    shoot_box.fixture = love.physics.newFixture(entity.body, shoot_box.shape)
    shoot_box.fixture:setSensor(true)
    shoot_box.fixture:setUserData({
        entity = entity,
        caller = "ai",
        name = "shoot_box"
    })

    CategoryManager.setObject(shoot_box.fixture, entity.tank.team)

    fill_table(entity.ai, {
        messages = Stack(),
        stack = Stack(),

        shoot_box = shoot_box,

        target = self.target,
        target_pos = nil,
        in_shoot_range = false,

        stare_timer_max = 1,
        stare_timer = 0,

        --ram_timer = 0,
        --ram_timer_max = 20,
        --ram_reloaded = true,
        --in_ram_range = false,
        --
        --ram_anticipation_timer = 0,
        --ram_anticipation_max = 5
    })
end

function AITank:process(entity, dt)
    local ai = entity.ai

    --if ai.ram_reloaded then
    --    ai.ram_timer = ai.ram_timer + dt
    --end
    --if ai.ram_timer > ai.ram_timer_max then
    --    ai.ram_reloaded = true
    --end

    --- Messages
    while ai.messages:size() ~= 0 do
        local message = entity.ai.messages:pop()
        local command = message[1]

        if self[command] then
            self[command](self, entity, dt, message[2])
        end
    end

    --- Stack-machine stuff
    if ai.stack:size() == 0 then
        ai.stack:push("idle")
    end

    local state = ai.stack:pop()
    self[state](self, entity, dt)
end

function AITank:contact(entity, dt, data)
    local other = data[2]
    local this = data[1]

    if this.name ~= "shoot_box" then
        return
    end

    if other.entity == entity.ai.target then
        entity.ai.in_shoot_range = true
    end
end

function AITank:endContact(entity, dt, data)
    local other = data[2]
    local this = data[1]

    if this.name ~= "shoot_box" then
        return
    end
    if other.entity == entity.ai.target then
        entity.ai.in_shoot_range = false
    end
end

function AITank:idle(entity, dt)
    local ai = entity.ai

    --if ai.in_ram_range then
    --    ai.stack:push("ramAwait")
    --    return
    --end

    if ai.in_shoot_range then
        entity.ai.target_pos = Vector2(entity.ai.target.body:getPosition())
        ai.stack:push("aiming")
        return
    end

    entity.tank.messages:push({"move", Vector2({-0.3, 0})})
    entity.tank.messages:push({"aim", Vector2(entity.body:getPosition()) + {-10, 0}})
end

--function AITank:ramAwait(entity, dt)
--    local ai = entity.ai
--    entity.tank.messages:push("stop")
--
--end
--
--function AITank:ram(entity, dt)
--
--end

function AITank:aiming(entity, dt)
    local ai = entity.ai
    entity.tank.messages:push({"stop"})
    entity.tank.messages:push({"aim", entity.ai.target_pos})

    if ai.stare_timer < ai.stare_timer_max then
        ai.stare_timer = ai.stare_timer + dt
        if not entity.ai.target.body:isDestroyed() then
            entity.ai.target_pos = Vector2(entity.ai.target.body:getPosition())
        end
        ai.stack:push("aiming")
        return
    end

    if not entity.tank.reload_timer.is_on then
        ai.stare_timer = 0
        entity.tank.messages:push({"shoot"})
    end
end

return AITank

